package db

import (
	"fmt"
	"oss-compliance-scanner/models"
)

// Vulnerability Operations

// CreateVulnerability creates a new vulnerability record
func (db *Database) CreateVulnerability(vulnerability *models.Vulnerability) error {
	return db.orm.Create(vulnerability).Error
}

// GetVulnerabilitiesByComponent retrieves all vulnerabilities for a component
func (db *Database) GetVulnerabilitiesByComponent(componentID int) ([]*models.Vulnerability, error) {
	var vulnerabilities []*models.Vulnerability
	err := db.orm.Where("component_id = ?", componentID).Find(&vulnerabilities).Error
	if err != nil {
		return nil, fmt.Errorf("failed to get vulnerabilities: %w", err)
	}
	return vulnerabilities, nil
}

// GetVulnerabilitiesBySBOM retrieves vulnerabilities for a specific SBOM with component information
func (db *Database) GetVulnerabilitiesBySBOM(sbomID int) ([]*models.Vulnerability, error) {
	query := `
		SELECT v.id, v.component_id, v.vuln_id, v.severity, v.cvss2_score, v.cvss3_score,
		       v.description, v.urls_json, v.published_date, v.modified_date, v.fixes_json,
		       v.metadata_json, v.created_at, v.updated_at,
		       c.name as component_name, c.version as component_version, c.type as component_type
		FROM vulnerabilities v
		JOIN components c ON v.component_id = c.id
		WHERE c.sbom_id = ?
		ORDER BY v.severity DESC, c.name ASC, v.created_at DESC
	`

	rows, err := db.conn.Query(query, sbomID)
	if err != nil {
		return nil, fmt.Errorf("failed to query vulnerabilities by SBOM: %w", err)
	}
	defer rows.Close()

	var vulnerabilities []*models.Vulnerability
	for rows.Next() {
		vuln := &models.Vulnerability{}
		var componentName, componentVersion, componentType string

		err := rows.Scan(
			&vuln.ID, &vuln.ComponentID, &vuln.VulnID, &vuln.Severity,
			&vuln.CVSS2Score, &vuln.CVSS3Score, &vuln.Description,
			&vuln.URLsJSON, &vuln.PublishedDate, &vuln.ModifiedDate,
			&vuln.FixesJSON, &vuln.MetadataJSON, &vuln.CreatedAt, &vuln.UpdatedAt,
			&componentName, &componentVersion, &componentType,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}

		// Unmarshal JSON fields
		if err := vuln.UnmarshalVulnerabilityFields(); err != nil {
			return nil, fmt.Errorf("failed to unmarshal vulnerability fields: %w", err)
		}

		// Add actual component info to metadata
		if vuln.Metadata == nil {
			vuln.Metadata = make(map[string]any)
		}
		vuln.Metadata["component_name"] = componentName
		vuln.Metadata["component_version"] = componentVersion
		vuln.Metadata["component_type"] = componentType
		vuln.Metadata["component_id"] = vuln.ComponentID

		vulnerabilities = append(vulnerabilities, vuln)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating vulnerabilities: %w", err)
	}

	return vulnerabilities, nil
}

// GetAllVulnerabilities retrieves all vulnerabilities with component information
func (db *Database) GetAllVulnerabilities(limit int) ([]*models.Vulnerability, error) {
	query := `
		SELECT v.id, v.component_id, v.vuln_id, v.severity, v.cvss2_score, v.cvss3_score,
		       v.description, v.urls_json, v.published_date, v.modified_date, v.fixes_json,
		       v.metadata_json, v.created_at, v.updated_at,
		       c.name as component_name, c.version as component_version, c.type as component_type,
		       s.repo_name, s.module_path
		FROM vulnerabilities v
		JOIN components c ON v.component_id = c.id
		JOIN sboms s ON c.sbom_id = s.id
		ORDER BY
			CASE v.severity
				WHEN 'Critical' THEN 1
				WHEN 'High' THEN 2
				WHEN 'Medium' THEN 3
				WHEN 'Low' THEN 4
				ELSE 5
			END,
			v.created_at DESC
		LIMIT ?
	`

	rows, err := db.conn.Query(query, limit)
	if err != nil {
		return nil, fmt.Errorf("failed to query all vulnerabilities: %w", err)
	}
	defer rows.Close()

	var vulnerabilities []*models.Vulnerability
	for rows.Next() {
		vuln := &models.Vulnerability{}
		var componentName, componentVersion, componentType, repoName, modulePath string

		err := rows.Scan(
			&vuln.ID, &vuln.ComponentID, &vuln.VulnID, &vuln.Severity,
			&vuln.CVSS2Score, &vuln.CVSS3Score, &vuln.Description,
			&vuln.URLsJSON, &vuln.PublishedDate, &vuln.ModifiedDate,
			&vuln.FixesJSON, &vuln.MetadataJSON, &vuln.CreatedAt, &vuln.UpdatedAt,
			&componentName, &componentVersion, &componentType, &repoName, &modulePath,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability: %w", err)
		}

		// Unmarshal JSON fields
		if err := vuln.UnmarshalVulnerabilityFields(); err != nil {
			return nil, fmt.Errorf("failed to unmarshal vulnerability fields: %w", err)
		}

		// Add component and repository info to metadata
		if vuln.Metadata == nil {
			vuln.Metadata = make(map[string]any)
		}
		vuln.Metadata["component_name"] = componentName
		vuln.Metadata["component_version"] = componentVersion
		vuln.Metadata["component_type"] = componentType
		vuln.Metadata["repo_name"] = repoName
		vuln.Metadata["module_path"] = modulePath

		vulnerabilities = append(vulnerabilities, vuln)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("error iterating vulnerabilities: %w", err)
	}

	return vulnerabilities, nil
}

// getTopVulnerabilities gets top vulnerabilities for a repository
func (db *Database) getTopVulnerabilities(repoName string, whereClause string, args []any, limit int) ([]models.VulnerabilityReport, error) {
	// Build query to get top vulnerabilities
	vulnQuery := fmt.Sprintf(`
		SELECT DISTINCT
			v.vuln_id,
			v.severity,
			v.cvss3_score,
			v.description,
			c.name as component_name,
			c.version as component_version,
			s.repo_name,
			v.published_date,
			CASE WHEN v.fixes_json IS NOT NULL AND v.fixes_json != '[]' THEN 1 ELSE 0 END as fix_available
		FROM vulnerabilities v
		JOIN components c ON v.component_id = c.id
		JOIN sboms s ON c.sbom_id = s.id
		WHERE %s AND s.repo_name = ?
		ORDER BY 
			CASE v.severity 
				WHEN 'Critical' THEN 4 
				WHEN 'High' THEN 3 
				WHEN 'Medium' THEN 2 
				WHEN 'Low' THEN 1 
				ELSE 0 
			END DESC,
			v.cvss3_score DESC
		LIMIT ?`, whereClause)

	vulnArgs := append(args, repoName, limit)
	rows, err := db.conn.Query(vulnQuery, vulnArgs...)
	if err != nil {
		return nil, fmt.Errorf("failed to get top vulnerabilities: %w", err)
	}
	defer rows.Close()

	var vulnerabilities []models.VulnerabilityReport
	for rows.Next() {
		var vuln models.VulnerabilityReport
		var fixAvailable int

		err := rows.Scan(
			&vuln.VulnID, &vuln.Severity, &vuln.CVSS3Score,
			&vuln.Description, &vuln.ComponentName, &vuln.ComponentVersion,
			&vuln.RepoName, &vuln.PublishedDate, &fixAvailable,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to scan vulnerability report: %w", err)
		}

		vuln.FixAvailable = fixAvailable == 1
		vulnerabilities = append(vulnerabilities, vuln)
	}

	return vulnerabilities, nil
}
